#+startup: indent outline
#+options: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline author:t
#+options: broken-links:nil c:nil creator:nil d:(not "LOGBOOK") date:t e:t
#+options: email:nil f:t inline:t num:t p:nil pri:nil prop:nil stat:t tags:t
#+options: tasks:t tex:t timestamp:t title:t toc:t todo:t |:t
#+title: advent-of-code-2022
#+date: <2022-12-01 Do>
#+author: Raffael Golomingi
#+email: raffael.golomingi@zhaw.ch
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 28.2 (Org mode 9.5.5)
#+cite_export:

* Dependencies

Here are the dependencies listed which I need.

#+name: deps.edn
#+begin_src clojure :tangle ./deps.edn :results silent
{:deps {}}
#+end_src

* Day 1
** Clojure
*** Part 1
#+begin_src clojure :results value pp replace :exports both
(def testinput [[1000
                 2000
                 3000]

                [4000]

                [5000
                 6000]

                [7000
                 8000
                 9000]

                [10000]])
;; test if it works
(inc (first (apply max-key second (map-indexed vector (mapv #(apply + %) testinput)))))

(defn get-elf-with-max-calories [c]
  (->> c
       (mapv #(apply + %))
       (map-indexed vector)
       (apply max-key second)))

(def input-day-1 (slurp "./input/input-day-1.txt"))

(->> input-day-1
     (clojure.string/split-lines)
     (split-with #(= "" %))
    )

(->> (clojure.string/split  input-day-1 #"\n\n")
     (map #(clojure.string/split-lines %))
     (mapv (fn [i] (mapv #(Integer/parseInt %) i)))
     (get-elf-with-max-calories )
     (second))
#+end_src

#+RESULTS:
: 68923
:

*** Part 2

#+begin_src clojure :results value pp replace :exports both
(def testinput [[1000
                 2000
                 3000]

                [4000]

                [5000
                 6000]

                [7000
                 8000
                 9000]

                [10000]])


(def input-day-1 (slurp "./input/input-day-1.txt"))

(->> input-day-1
     (clojure.string/split-lines)
     (split-with #(= "" %)))



(->> testinput
     (mapv #(apply + %))
     (sort)
     (reverse)
     (take 3)
     (reduce +))



(->> (clojure.string/split  input-day-1 #"\n\n")
     (map #(clojure.string/split-lines %))
     (mapv (fn [i] (mapv #(Integer/parseInt %) i)))
     (mapv #(apply + %))
     (sort)
     (reverse)
     (take 3)
     (reduce +))
#+end_src

#+RESULTS:
: 200044
:

** Elisp
*** part 1
#+begin_src elisp :results replace :exports both
(setq input-day-1 (with-temp-buffer (insert-file-contents "./input/input-day-1.txt")
                                    (split-string (buffer-string) "\n\n" t)))

(setq input-parsed (mapcar (lambda (i) (mapcar 'string-to-number i))
                          (mapcar (lambda (i) (split-string i "\n")) input-day-1)))

(apply 'max (mapcar (lambda (i) (apply '+ i)) input-parsed))

#+end_src

#+RESULTS:
: 68923

*** part 2
#+begin_src elisp :results replace :exports both
(require 'seq)
(setq input-day-1 (with-temp-buffer (insert-file-contents "./input/input-day-1.txt")
                                    (split-string (buffer-string) "\n\n" t)))

(setq input-parsed (mapcar (lambda (i) (mapcar 'string-to-number i))
                          (mapcar (lambda (i) (split-string i "\n")) input-day-1)))

(apply '+ (seq-take (sort (mapcar (lambda (i) (apply '+ i)) input-parsed) '>) 3))

#+end_src

#+RESULTS:
: 200044


* Day 2

** Clojure
*** Part 1
#+begin_src clojure :results value pp replace :exports both

(def test-input ["A Y"
                 "B X"
                 "C Z"])

(def lookup {"A Y" 8
             "A X" 4
             "A Z" 3

             "B Y" 5
             "B Z" 9
             "B X" 1
             "C X" 7
             "C Y" 2
             "C Z" 6})

(reduce + (map #(get lookup %) test-input))

(def game-input (->> (slurp "./input/input-day-2.txt")
                     (clojure.string/split-lines)))

(reduce + (map #(get lookup %) game-input))
#+end_src

#+RESULTS:
: 15523
:
*** Part 2

#+begin_src clojure :results value pp replace :exports both

(def test-input ["A Y"
                 "B X"
                 "C Z"])


(def lookup {"A X" (+ 0 3)
             "A Y" (+ 3 1)
             "A Z" (+ 6 2)

             "B X" (+ 0 1)
             "B Y" (+ 3 2)
             "B Z" (+ 6 3)

             "C X" (+ 0 2)
             "C Y" (+ 3 3)
             "C Z" (+ 6 1) })

(reduce + (map #(get lookup %) test-input))

(def game-input (->> (slurp "./input/input-day-2.txt")
                     (clojure.string/split-lines)))

(reduce + (map #(get lookup %) game-input))
#+end_src

#+RESULTS:
: 15702
:
** Elisp
*** Part 1

#+begin_src elisp :results pp replace :exports both
(require 'seq)
(setq input-day-2 (with-temp-buffer (insert-file-contents "./input/input-day-2.txt")
                                    (butlast (string-lines (buffer-string)))))

(setq lookup '(("A X" . 4)
               ("A Y" . 8)
               ("A Z" . 3)
               ("B X" . 1)
               ("B Y" . 5)
               ("B Z" . 9)
               ("C X" . 7)
               ("C Y" . 2)
               ("C Z" . 6)))

(setq test-input '("A Y"
                   "B X"
                   "C Z"))

(seq-reduce #'+ (mapcar (lambda (i) (cdr (assoc i lookup))) test-input) 0)


(seq-reduce #'+ (mapcar (lambda (i) (cdr (assoc i lookup))) input-day-2) 0)
#+end_src

#+RESULTS:
: 15523

*** Part 2

#+begin_src elisp :results replace :exports both
(require 'seq)
(setq input-day-2 (with-temp-buffer (insert-file-contents "./input/input-day-2.txt")
                                    (butlast (string-lines (buffer-string)))))

(setq lookup '(("A X" . 3)
               ("A Y" . 4)
               ("A Z" . 8)
               ("B X" . 1)
               ("B Y" . 5)
               ("B Z" . 9)
               ("C X" . 2)
               ("C Y" . 6)
               ("C Z" . 7)))

(setq test-input '("A Y"
                   "B X"
                   "C Z"))

(seq-reduce #'+ (mapcar (lambda (i) (cdr (assoc i lookup))) test-input) 0)


(seq-reduce #'+ (mapcar (lambda (i) (cdr (assoc i lookup))) input-day-2) 0)
#+end_src

#+RESULTS:
: 15702

* Day 3

** Clojure
*** Part 1
#+begin_src clojure :results value pp replace :exports both
(def testinput ["vJrwpWtwJgWrhcsFMMfFFhFp"
                "jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL"
                "PmmdzqPrVvPwwTWBwg"
                "wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn"
                "ttgJtRGJQctTZtZT"
                "CrZsJsPPZsGzwwsLwLmpwMDw"] )

(def alphabet (clojure.string/join (map char (range (int \a) (inc(int \z))))))

(def lookup (str alphabet (clojure.string/upper-case alphabet)))




(defn get-intersection [c]
  (let [ind (/ (count c) 2)]
    (clojure.set/intersection (set (take ind c)) (set (nthrest c ind)))))

(defn get-priority [char]
 (clojure.string/index-of lookup char)
  )

(->> testinput
     (map get-intersection)
     (map first)
     (map str)
     (map get-priority)
     (map inc)
     (reduce +))

(def input-day-3 (->> "./input/input-day-3.txt"
                      (slurp)
                      (clojure.string/split-lines)))
(->> input-day-3
     (map get-intersection)
     (map first)
     (map str)
     (map get-priority)
     (map inc)
     (reduce +))
#+end_src

#+RESULTS:
: 7845
:
*** Part 2

#+begin_src clojure :results value pp replace :exports both
(def testinput ["vJrwpWtwJgWrhcsFMMfFFhFp"
                "jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL"
                "PmmdzqPrVvPwwTWBwg"
                "wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn"
                "ttgJtRGJQctTZtZT"
                "CrZsJsPPZsGzwwsLwLmpwMDw"] )

(->> testinput
     (partition 3)
     (first)
     (map set)
     (apply clojure.set/intersection)
     )

(def alphabet (clojure.string/join (map char (range (int \a) (inc(int \z))))))

(def lookup (str alphabet (clojure.string/upper-case alphabet)))


(defn get-priority [char]
 (clojure.string/index-of lookup char))

(->> testinput
     (map get-intersection)
     (map first)
     (map str)
     (map get-priority)
     (map inc)
     (reduce +))

(->> testinput
     (partition 3)
     (map (fn [i] (map set i)))
     (map (fn [i] (apply clojure.set/intersection i)))
     (map first)
     (map str)
     (map get-priority)
     (map inc)
     (reduce +))


(def input-day-3 (->> "./input/input-day-3.txt"
                      (slurp)
                      (clojure.string/split-lines)))

(->> input-day-3
     (partition 3)
     (map (fn [i] (map set i)))
     (map (fn [i] (apply clojure.set/intersection i)))
     (map first)
     (map str)
     (map get-priority)
     (map inc)
     (reduce +))
#+end_src

#+RESULTS:
: 2790
:

** Elisp
*** Part 1

#+begin_src elisp :results pp replace :exports both
(require 'seq)
(require 'cl-lib)


(setq testinput '("vJrwpWtwJgWrhcsFMMfFFhFp"
                 "jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL"
                 "PmmdzqPrVvPwwTWBwg"
                 "wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn"
                 "ttgJtRGJQctTZtZT"
                 "CrZsJsPPZsGzwwsLwLmpwMDw"))


(setq alphabet (string-join (mapcar (lambda (i) (format "%c" i)) (number-sequence ?a ?z))))

(setq lookup (concat alphabet (upcase alphabet)))

(defun get-priorites (char col)
  (+ 1 (string-search char col)))

(defun get-intersection (col)
  (let ((ind (/ (length col) 2)))
    (format "%c" (car (seq-intersection (seq-take col ind) (seq-drop col ind))))))

(seq-reduce #'+ (mapcar (lambda (i) (get-priorites i lookup)) (mapcar 'get-intersection testinput)) 0)

(setq input-day-3 (with-temp-buffer (insert-file-contents "./input/input-day-3.txt")
                                    (butlast (string-lines (buffer-string)))))


(seq-reduce #'+ (mapcar (lambda (i) (get-priorites i lookup)) (mapcar 'get-intersection input-day-3)) 0)
#+end_src

#+RESULTS:
: 7845

*** Part 2

#+begin_src elisp :results replace :exports both
(require 'seq)
(require 'cl-lib)


(setq testinput '("vJrwpWtwJgWrhcsFMMfFFhFp"
                 "jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL"
                 "PmmdzqPrVvPwwTWBwg"
                 "wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn"
                 "ttgJtRGJQctTZtZT"
                 "CrZsJsPPZsGzwwsLwLmpwMDw"))


(setq alphabet (string-join (mapcar (lambda (i) (format "%c" i)) (number-sequence ?a ?z))))

(setq lookup (concat alphabet (upcase alphabet)))

(defun get-priorites (char col)
  (+ 1 (string-search char col)))

(defun get-intersection (col)
  (let ((ind (/ (length col) 2)))
    (format "%c" (car (seq-intersection (seq-take col ind) (seq-drop col ind))))))

(defun my-intersection (i)
  (format "%c" (car
                (seq-intersection (seq-first i) (seq-intersection (car (cdr i)) (car (last i)))))))


(seq-reduce #'+ (mapcar (lambda (i) (get-priorites i lookup))
                       (mapcar 'my-intersection(mapcar (lambda (i)
                                                         (mapcar 'string-to-list i))
                                                       (seq-partition testinput 3)))) 0)

(setq input-day-3 (with-temp-buffer (insert-file-contents "./input/input-day-3.txt")
                                    (butlast (string-lines (buffer-string)))))


(seq-reduce #'+ (mapcar (lambda (i) (get-priorites i lookup))
                       (mapcar 'my-intersection(mapcar (lambda (i)
                                                         (mapcar 'string-to-list i))
                                                       (seq-partition input-day-3 3)))) 0)
#+end_src

#+RESULTS:
: 2790

* Day 4

** Clojure
*** Part 1
#+begin_src clojure :results value pp replace :exports both

(defn pairs-to-sets [c]
  (->> c
       (map #(clojure.string/split % #"-"))
       (map (fn [i] (map #(Integer/parseInt %) i)))
       (map (fn [i] (set (range (first i) (inc (second i))))))))

(def testinput (->>["2-4,6-8"
                    "2-3,4-5"
                    "5-7,7-9"
                    "2-8,3-7"
                    "6-6,4-6"
                    "2-6,4-8"]
                   (map #(clojure.string/split % #","))))

(->> testinput
     (map pairs-to-sets)
     (filter #(or (clojure.set/subset? (first %) (second %))
                  (clojure.set/subset? (second %) (first %))))
     (count))

(def input-day-4 (->> "./input/input-day-4.txt"
                      (slurp)
                      (clojure.string/split-lines)
                      (map #(clojure.string/split % #","))))
(->> input-day-4
     (map pairs-to-sets)
     (filter #(or (clojure.set/subset? (first %) (second %))
                  (clojure.set/subset? (second %) (first %))))
     (count))
#+end_src

#+RESULTS:
: 657
:
*** Part 2

#+begin_src clojure :results value pp replace :exports both

(defn pairs-to-sets [c]
  (->> c
       (map #(clojure.string/split % #"-"))
       (map (fn [i] (map #(Integer/parseInt %) i)))
       (map (fn [i] (set (range (first i) (inc (second i))))))))

(def testinput (->>["2-4,6-8"
                    "2-3,4-5"
                    "5-7,7-9"
                    "2-8,3-7"
                    "6-6,4-6"
                    "2-6,4-8"]
                   (map #(clojure.string/split % #","))))

(->> testinput
     (map pairs-to-sets)
     (map #(apply clojure.set/intersection %))
     (filter not-empty)
     (count)
     )


(def input-day-4 (->> "./input/input-day-4.txt"
                      (slurp)
                      (clojure.string/split-lines)
                      (map #(clojure.string/split % #","))))
(->> input-day-4
     (map pairs-to-sets)
     (map #(apply clojure.set/intersection %))
     (filter not-empty)
     (count)
     )
#+end_src

#+RESULTS:
: 938
:

** Elisp
*** Part 1

#+begin_src elisp :results pp replace :exports both
(require 'seq)
(require 'cl-lib)

(setq testinput '("2-4,6-8"
                  "2-3,4-5"
                  "5-7,7-9"
                  "2-8,3-7"
                  "6-6,4-6"
                  "2-6,4-8"))

(defun parse-to-list (i)
  (thread-last (split-string i ",")
               (mapcar (lambda (i) (split-string i "-")))
               (mapcar (lambda (i) (number-sequence (string-to-number (car i))
                                                    (string-to-number (car (cdr i))))))))

(thread-last testinput
             (mapcar 'parse-to-list)
             (seq-filter (lambda (i)
                           (or (cl-subsetp (car i) (car (cdr i)))
                               (cl-subsetp (car (cdr i)) (car i)))))
             (seq-length))

(setq input-day-4 (with-temp-buffer (insert-file-contents "./input/input-day-4.txt")
                                    (butlast (string-lines (buffer-string)))))

(thread-last input-day-4
             (mapcar 'parse-to-list)
             (seq-filter (lambda (i)
                           (or (cl-subsetp (car i) (car (cdr i)))
                               (cl-subsetp (car (cdr i)) (car i)))))
             (seq-length))
#+end_src

#+RESULTS:
: 657

*** Part 2

#+begin_src elisp :results pp replace :exports both
(require 'seq)
(require 'cl-lib)


(setq testinput '("2-4,6-8"
                  "2-3,4-5"
                  "5-7,7-9"
                  "2-8,3-7"
                  "6-6,4-6"
                  "2-6,4-8"))

(defun parse-to-list (i)
  (thread-last (split-string i ",")
               (mapcar (lambda (i) (split-string i "-")))
               (mapcar (lambda (i) (number-sequence (string-to-number (car i))
                                                    (string-to-number (car (cdr i))))))))

(thread-last testinput
             (mapcar 'parse-to-list)
             (mapcar (lambda (i) (apply 'seq-intersection i)))
             (seq-remove (lambda (i) (equal nil i)))
             (seq-length))

(setq input-day-4 (with-temp-buffer (insert-file-contents "./input/input-day-4.txt")
                                    (butlast (string-lines (buffer-string)))))

(thread-last input-day-4
             (mapcar 'parse-to-list)
             (mapcar (lambda (i) (apply 'seq-intersection i)))
             (seq-remove (lambda (i) (equal nil i)))
             (seq-length))
#+end_src

#+RESULTS:
: 938

* Day 5

** Clojure
*** Part 1
#+begin_src clojure :results value pp replace :exports both
(def testinput (-> "    [D]    \n[N] [C]    \n[Z] [M] [P]\n 1   2   3\n\nmove 1 from 2 to 1\nmove 3 from 1 to 3\nmove 2 from 2 to 1\nmove 1 from 1 to 2"
                   (clojure.string/split #"\n\n")
                   (->> (map clojure.string/split-lines)
                        (into '[]))))

(defn make-game-board [col]
  (let [crates (->> col
                    (mapv #(into '[] (partition 3 4 %)))
                    (mapv (fn [i] (mapv #(clojure.string/trim (clojure.string/join %)) i))))
        partitions (count crates)]
    (->> crates
         (apply interleave)
         (partition partitions)
         (mapv #(into '[] %))
         (mapv (fn [i]
                 (filter #(not= "" %) i))))))

(defn do-move [board s]
  (let [split (clojure.string/split s #" ")
        amount (Integer/parseInt (nth split 1))
        from (dec (Integer/parseInt (nth split 3)))
        to   (dec (Integer/parseInt (nth split 5)))
        boxes (reverse (take amount (nth board from)))]
    (-> board
        (update from #(drop amount %))
        (update to #(flatten (cons boxes %))))))


(map first (reduce do-move (make-game-board (butlast (first testinput))) (second testinput)))


(def input-day-5 (-> "./input/input-day-5.txt"
                      (slurp)
                      (clojure.string/split #"\n\n")
                      (->> (map clojure.string/split-lines)
                           (into '[]))))

(map first (reduce do-move (make-game-board (butlast (first input-day-5))) (second input-day-5)))
#+end_src

#+RESULTS:
: ("[P]" "[T]" "[W]" "[L]" "[T]" "[D]" "[S]" "[J]" "[V]")
:
*** Part 2

#+begin_src clojure :results value pp replace :exports both
(def testinput (-> "    [D]    \n[N] [C]    \n[Z] [M] [P]\n 1   2   3\n\nmove 1 from 2 to 1\nmove 3 from 1 to 3\nmove 2 from 2 to 1\nmove 1 from 1 to 2"
                   (clojure.string/split #"\n\n")
                   (->> (map clojure.string/split-lines)
                        (into '[]))))

(defn make-game-board [col]
  (let [crates (->> col
                    (mapv #(into '[] (partition 3 4 %)))
                    (mapv (fn [i] (mapv #(clojure.string/trim (clojure.string/join %)) i))))
        partitions (count crates)]
    (->> crates
         (apply interleave)
         (partition partitions)
         (mapv #(into '[] %))
         (mapv (fn [i]
                 (filter #(not= "" %) i))))))

(defn do-move [board s]
  (let [split (clojure.string/split s #" ")
        amount (Integer/parseInt (nth split 1))
        from (dec (Integer/parseInt (nth split 3)))
        to   (dec (Integer/parseInt (nth split 5)))
        boxes  (take amount (nth board from))]
    (-> board
        (update from #(drop amount %))
        (update to #(flatten (cons boxes %))))))


(map first (reduce do-move (make-game-board (butlast (first testinput))) (second testinput)))


(def input-day-5 (-> "./input/input-day-5.txt"
                      (slurp)
                      (clojure.string/split #"\n\n")
                      (->> (map clojure.string/split-lines)
                           (into '[]))))

(map first (reduce do-move (make-game-board (butlast (first input-day-5))) (second input-day-5)))
#+end_src

#+RESULTS:
: ("[W]" "[Z]" "[M]" "[F]" "[V]" "[G]" "[G]" "[Z]" "[P]")
:

** Elisp
*** Part 1

#+begin_src elisp :results pp replace :exports both
(require 'seq)
(require 'cl-lib)


(setq testinput (thread-first "    [D]    \n[N] [C]    \n[Z] [M] [P]\n 1   2   3\n\nmove 1 from 2 to 1\nmove 3 from 1 to 3\nmove 2 from 2 to 1\nmove 1 from 1 to 2"
                              (split-string "\n\n")
                              (thread-last (mapcar 'string-lines))))




(defun partition-by-step (sequence n step)
  (let ((total '()))
    (while (not (seq-empty-p sequence))
      (setq total (concat total (seq-take sequence n)))
      (setq sequence (seq-drop sequence (+ n step)))
      )
    (seq-partition total n))
  )

(defun make-game-board (col)
  (let ((crates (thread-last col
                             (mapcar (lambda (i) (partition-by-step i 3 1)))
                             (apply #'seq-mapn #'list)
                             (mapcar (lambda (i) (seq-remove #'string-empty-p
                                                        (mapcar 'string-trim  i))))
                             )))crates))


(defun do-move (board s)
  (let* ((split (split-string s " "))
         (amount (string-to-number (nth 1 split)))
         (from (1- (string-to-number (nth 3 split))))
         (to (1-(string-to-number (nth 5 split))))
         (boxes (seq-reverse (seq-take (nth from board) amount)))
         (removed-boxes (seq-drop (nth from board) amount))
         (tmp-board (cl-subst (if (seq-empty-p removed-boxes) (make-list (1+ from) nil) removed-boxes)
                              (nth from board)
                              board
                              :test 'eq)))
    (cl-subst (flatten-list (cons boxes (nth to tmp-board)))
              (nth to tmp-board)
              tmp-board
              :test 'eq)))

(mapcar 'seq-first (seq-reduce #'do-move (cadr testinput) (make-game-board (butlast (car testinput)))))


(setq input-day-5 (with-temp-buffer (insert-file-contents "./input/input-day-5.txt")
                                    (thread-first (buffer-string)
                                                 (split-string "\n\n")
                                                 (thread-last (mapcar 'string-lines)))))


(mapcar 'seq-first (seq-reduce #'do-move (butlast (cadr input-day-5)) (make-game-board (butlast (car input-day-5)))))
#+end_src

#+RESULTS:
: ("[P]" "[T]" "[W]" "[L]" "[T]" "[D]" "[S]" "[J]" "[V]")

*** Part 2

#+begin_src elisp :results pp replace :exports both
(require 'seq)
(require 'cl-lib)



(setq testinput (thread-first "    [D]    \n[N] [C]    \n[Z] [M] [P]\n 1   2   3\n\nmove 1 from 2 to 1\nmove 3 from 1 to 3\nmove 2 from 2 to 1\nmove 1 from 1 to 2"
                              (split-string "\n\n")
                              (thread-last (mapcar 'string-lines))))




(defun partition-by-step (sequence n step)
  (let ((total '()))
    (while (not (seq-empty-p sequence))
      (setq total (concat total (seq-take sequence n)))
      (setq sequence (seq-drop sequence (+ n step)))
      )
    (seq-partition total n))
  )

(defun make-game-board (col)
  (let ((crates (thread-last col
                             (mapcar (lambda (i) (partition-by-step i 3 1)))
                             (apply #'seq-mapn #'list)
                             (mapcar (lambda (i) (seq-remove #'string-empty-p
                                                        (mapcar 'string-trim  i))))
                             )))crates))


(defun do-move (board s)
  (let* ((split (split-string s " "))
         (amount (string-to-number (nth 1 split)))
         (from (1- (string-to-number (nth 3 split))))
         (to (1-(string-to-number (nth 5 split))))
         (boxes (seq-take (nth from board) amount))
         (removed-boxes (seq-drop (nth from board) amount))
         (tmp-board (cl-subst (if (seq-empty-p removed-boxes) (make-list (1+ from) nil) removed-boxes)
                              (nth from board)
                              board
                              :test 'eq)))
    (cl-subst (flatten-list (cons boxes (nth to tmp-board)))
              (nth to tmp-board)
              tmp-board
              :test 'eq)))

(mapcar 'seq-first (seq-reduce #'do-move (cadr testinput) (make-game-board (butlast (car testinput)))))


(setq input-day-5 (with-temp-buffer (insert-file-contents "./input/input-day-5.txt")
                                    (thread-first (buffer-string)
                                                 (split-string "\n\n")
                                                 (thread-last (mapcar 'string-lines)))))


(mapcar 'seq-first (seq-reduce #'do-move (butlast (cadr input-day-5)) (make-game-board (butlast (car input-day-5)))))
#+end_src

#+RESULTS:
: ("[W]" "[Z]" "[M]" "[F]" "[V]" "[G]" "[G]" "[Z]" "[P]")

* Day 6

** Clojure
*** Part 1
#+begin_src clojure :results value pp replace :exports both
(def testinput  ["mjqjpqmgbljsphdztnvjfqwrcgsmlb"
                "zcfzfwzzqfrljwzlrfnpqdbhtmscgvjw" ])

(->> (partition 4 1 (second testinput))

     (take-while #(not (apply distinct? %)))
     (last)
     (clojure.string/join)
     (clojure.string/index-of (second testinput))
     (+ 5)
     )

(def input-day-6 (->> "./input/input-day-6.txt"
                      (slurp))
  )

(->> (partition 4 1 input-day-6)
     (take-while #(not (apply distinct? %)))
     (last)
     (clojure.string/join)
     (clojure.string/index-of input-day-6)
     (+ 5)
     )
#+end_src

#+RESULTS:
: 1953
:
*** Part 2

#+begin_src clojure :results value pp replace :exports both
(def testinput  ["mjqjpqmgbljsphdztnvjfqwrcgsmlb"])

(->> (partition 14 1 (first testinput))

     (take-while #(not (apply distinct? %)))
     (last)
     (clojure.string/join)
     (clojure.string/index-of (first testinput))
     (+ 15))

(def input-day-6 (->> "./input/input-day-6.txt"
                      (slurp)))

(->> (partition 14 1 input-day-6)
     (take-while #(not (apply distinct? %)))
     (last)
     (clojure.string/join)
     (clojure.string/index-of input-day-6)
     (+ 15))
#+end_src

#+RESULTS:
: 2301
:


** Elisp
*** Part 1

#+begin_src elisp :results pp replace :exports both
(require 'seq)
(require 'cl-lib)

(setq testinput "zcfzfwzzqfrljwzlrfnpqdbhtmscgvjw")

(defun partition-by-step (sequence n step)
  (let ((total '()))
    (while (not (seq-empty-p sequence))
      (setq total (concat total (seq-take sequence n)))
      (setq sequence (seq-drop sequence step))
      )
    (seq-partition total n))
  )


(thread-first testinput
              (partition-by-step 4 1)
              (thread-last
                (seq-take-while (lambda (i) (if (eq (seq-length i)
                                               (seq-length (seq-uniq i)))
                                           nil
                                         t)))
                (last)
                (car)
                )
              (string-match testinput)
              (+ 5))


(setq input-day-6 (with-temp-buffer (insert-file-contents "./input/input-day-6.txt")
                                    (buffer-string)))



(thread-first input-day-6
              (partition-by-step 4 1)
              (thread-last
                (seq-take-while (lambda (i) (if (eq (seq-length i)
                                               (seq-length (seq-uniq i)))
                                           nil
                                         t)))

                (last)
                (car))
              (string-match input-day-6)
              (+ 5))
#+end_src

#+RESULTS:
: 1953

*** Part 2

#+begin_src elisp :results pp replace :exports both
(require 'seq)
(require 'cl-lib)

(setq testinput "mjqjpqmgbljsphdztnvjfqwrcgsmlb")

(defun partition-by-step (sequence n step)
  (let ((total '()))
    (while (not (seq-empty-p sequence))
      (setq total (concat total (seq-take sequence n)))
      (setq sequence (seq-drop sequence step))
      )
    (seq-partition total n))
  )


(thread-first testinput
              (partition-by-step 14 1)
              (thread-last
                (seq-take-while (lambda (i) (if (eq (seq-length i)
                                               (seq-length (seq-uniq i)))
                                           nil
                                         t)))
                (last)
                (car)
                )
              (string-match testinput)
              (+ 15))


(setq input-day-6 (with-temp-buffer (insert-file-contents "./input/input-day-6.txt")
                                    (buffer-string)))



(thread-first input-day-6
              (partition-by-step 14 1)
              (thread-last
                (seq-take-while (lambda (i) (if (eq (seq-length i)
                                               (seq-length (seq-uniq i)))
                                           nil
                                         t)))

                (last)
                (car))
              (string-match input-day-6)
              (+ 15))
#+end_src

#+RESULTS:
: 2301
* Day 7

** Clojure
*** Part 1
#+begin_src clojure :results value pp replace :exports both
(def testinput (map #(clojure.string/split % #" ")["$ cd /"
                                                   "$ ls"
                                                   "dir a"
                                                   "14848514 b.txt"
                                                   "8504156 c.dat"
                                                   "dir d"
                                                   "$ cd a"
                                                   "$ ls"
                                                   "dir e"
                                                   "29116 f"
                                                   "2557 g"
                                                   "62596 h.lst"
                                                   "$ cd e"
                                                   "$ ls"
                                                   "584 i"
                                                   "$ cd .."
                                                   "$ cd .."
                                                   "$ cd d"
                                                   "$ ls"
                                                   "4060174 j"
                                                   "8033020 d.log"
                                                   "5626152 d.ext"
                                                   "7214296 k"]))
(defn create-dir-map [col]
  (loop [xs col file {} acc []]
    (if xs
      (let [x (first xs)]
        (cond (and (= (first x) "$")
                   (= (second x) "cd")
                   (not= (last x) "..")) (recur (next xs)  {:name (last x)
                                                            :dir []
                                                            :files []} (cons file acc))
              (and (= (first x) "$") (= (second x) "ls")) (recur (next xs) file acc)
              (and (= (first x) "$") (= (second x) "cd")
                   (= (last x) "..")) (recur (next xs) {} (cons file acc))
              (and (= (first x) "dir")) (recur (next xs) (update file :dir conj (last x)) acc)
              :else (recur (next xs) (update file :files conj x) acc)))

      (cons file acc))))

(defn calculate-file-size [i]
  (reduce +(map (fn [i] (Integer/parseInt (first i)))(:files i))))

(def dirs
  (->> testinput (create-dir-map)
       (filter not-empty)
       (map (fn [i] (assoc i :size (calculate-file-size i))))))


(for [d dirs]
  (let [subdirs (:dir d)
        sizes (flatten (map (fn [s] (map :size (filter #(= (:name %) s) dirs))) subdirs))
        sum-sizes (reduce + sizes)]
    (update d :size + sum-sizes))
  )


(defn get-subdirs [d dirs]
  (loop [xs (:dir d) subdirs []]
    (if xs
      (let [x (first xs)
            xdir (flatten (map :dir (filter #(= (:name %) x) dirs)))]
        (cond (not-empty xdir) (recur (flatten(conj (next xs) xdir)) (flatten (conj subdirs xdir)))
              :else (recur (next xs) subdirs)))

      (concat subdirs (:dir d)))))

(defn get-size-subdirs [d dirs]
  (let [subdirs (get-subdirs d dirs)]
    (+ (:size d)
       (->> subdirs
            (map (fn [d] (filter #(= d (:name %)) dirs)))
            (flatten)
            (map :size)
            (reduce +)))))

(->> dirs
    (map #(get-size-subdirs % dirs))
    (filter #(<= % 100000))
    )

(def input-day-7 (->> "./input/input-day-7.txt"
                      (slurp)
                      (clojure.string/split-lines)
                      (map #(clojure.string/split % #" "))))

(def dirs-7
  (as-> input-day-7 d
    (create-dir-map d)
    (filter not-empty d)
    (map (fn [i] (assoc i :size (calculate-file-size i))) d)))


(->> dirs-7
    (map #(get-size-subdirs % dirs))
    (filter #(< % 100000))
    )

#+end_src

#+RESULTS:
: Please reevaluate when nREPL is connected
*** Part 2

#+begin_src clojure :results value pp replace :exports both
(def testinput  ["mjqjpqmgbljsphdztnvjfqwrcgsmlb"])

(->> (partition 14 1 (first testinput))

     (take-while #(not (apply distinct? %)))
     (last)
     (clojure.string/join)
     (clojure.string/index-of (first testinput))
     (+ 15))

(def input-day-6 (->> "./input/input-day-6.txt"
                      (slurp)))

(->> (partition 14 1 input-day-6)
     (take-while #(not (apply distinct? %)))
     (last)
     (clojure.string/join)
     (clojure.string/index-of input-day-6)
     (+ 15))
#+end_src

#+RESULTS:
: 2301
:


** Elisp
*** Part 1

#+begin_src elisp :results pp replace :exports both
(require 'seq)
(require 'cl-lib)

(setq testinput "zcfzfwzzqfrljwzlrfnpqdbhtmscgvjw")

(defun partition-by-step (sequence n step)
  (let ((total '()))
    (while (not (seq-empty-p sequence))
      (setq total (concat total (seq-take sequence n)))
      (setq sequence (seq-drop sequence step))
      )
    (seq-partition total n))
  )


(thread-first testinput
              (partition-by-step 4 1)
              (thread-last
                (seq-take-while (lambda (i) (if (eq (seq-length i)
                                               (seq-length (seq-uniq i)))
                                           nil
                                         t)))
                (last)
                (car)
                )
              (string-match testinput)
              (+ 5))


(setq input-day-6 (with-temp-buffer (insert-file-contents "./input/input-day-6.txt")
                                    (buffer-string)))



(thread-first input-day-6
              (partition-by-step 4 1)
              (thread-last
                (seq-take-while (lambda (i) (if (eq (seq-length i)
                                               (seq-length (seq-uniq i)))
                                           nil
                                         t)))

                (last)
                (car))
              (string-match input-day-6)
              (+ 5))
#+end_src

#+RESULTS:
: 1953

*** Part 2

#+begin_src elisp :results pp replace :exports both
(require 'seq)
(require 'cl-lib)

(setq testinput "mjqjpqmgbljsphdztnvjfqwrcgsmlb")

(defun partition-by-step (sequence n step)
  (let ((total '()))
    (while (not (seq-empty-p sequence))
      (setq total (concat total (seq-take sequence n)))
      (setq sequence (seq-drop sequence step))
      )
    (seq-partition total n))
  )


(thread-first testinput
              (partition-by-step 14 1)
              (thread-last
                (seq-take-while (lambda (i) (if (eq (seq-length i)
                                               (seq-length (seq-uniq i)))
                                           nil
                                         t)))
                (last)
                (car)
                )
              (string-match testinput)
              (+ 15))


(setq input-day-6 (with-temp-buffer (insert-file-contents "./input/input-day-6.txt")
                                    (buffer-string)))



(thread-first input-day-6
              (partition-by-step 14 1)
              (thread-last
                (seq-take-while (lambda (i) (if (eq (seq-length i)
                                               (seq-length (seq-uniq i)))
                                           nil
                                         t)))

                (last)
                (car))
              (string-match input-day-6)
              (+ 15))
#+end_src

#+RESULTS:
: 2301

* Day 8

** Clojure
*** Part 1
#+begin_src clojure :results value pp replace :exports both
(def testinput [[3 0 3 7 3]
                [2 5 5 1 2]
                [6 5 3 3 2]
                [3 3 5 4 9]
                [3 5 3 9 0]] )

(def testinput-columns
  (partition  5 (count testinput) (apply interleave testinput)))

(nth testinput-columns 1)

(defn visible? [ind coll]
  (let [t (nth coll ind)
        trees-before (take ind coll)
        trees-after (nthrest coll (inc ind))]
    (or
     (every? #(> t %) trees-before)
     (every? #(> t %) trees-after)
     )))

(->> testinput
     (second)
     (visible? 2))


(defn get-visible-trees [treemap]
  (let [rows treemap
        columns (partition (count treemap) (apply interleave treemap))]
    (for [x (range 0 (count treemap)) y (range 0 (count (first treemap)))]
      (or (visible? y (nth rows x))
          (visible? x (nth columns y)))

      )))

(count (filter true? (get-visible-trees testinput)))

(def input-day-8 (->> "./input/input-day-8.txt"
                      (slurp)
                      (clojure.string/split-lines)
                      (map #(clojure.string/split % #""))
                      (mapv (fn [i] (mapv #(Integer/parseInt %) i)))))

(count (filter true? (get-visible-trees input-day-8)))
#+end_src

#+RESULTS:
: 1851
:
*** Part 2

#+begin_src clojure :results value pp replace :exports both
(def testinput [[3 0 3 7 3]
                [2 5 5 1 2]
                [6 5 3 3 2]
                [3 3 5 4 9]
                [3 5 3 9 0]] )


(defn my-take-while [i coll]
  (loop [[x & xs] coll acc []]
    (if x
      (cond (= x i) (conj acc true)
            (< i x) (conj acc true)
            (> i x) (recur xs (conj acc true))
            :else acc)
      acc)))

(defn count-visible-trees? [ind coll]
  (let [t (nth coll ind)
        trees-before (reverse (take ind coll))
        trees-after (nthrest coll (inc ind))]
    (* (count (my-take-while t trees-before))
       (count (my-take-while t trees-after)))
    ))

(->> testinput
     (second)
     (visible? 2))


(defn get-visible-trees [treemap]
  (let [rows treemap
        columns (partition (count treemap) (apply interleave treemap))]
    (for [x (range 0 (count treemap)) y (range 0 (count (first treemap)))]
      (* (count-visible-trees? y (nth rows x))
          (count-visible-trees? x (nth columns y)))

      )))

(apply max (get-visible-trees testinput))

(def input-day-8 (->> "./input/input-day-8.txt"
                      (slurp)
                      (clojure.string/split-lines)
                      (map #(clojure.string/split % #""))
                      (mapv (fn [i] (mapv #(Integer/parseInt %) i)))))

(apply max (get-visible-trees input-day-8))
#+end_src

#+RESULTS:
: 574080
:


** Elisp
*** Part 1

#+begin_src elisp :results pp replace :exports both
(require 'seq)
(require 'cl-lib)

(setq testinput '((3 0 3 7 3)
                  (2 5 5 1 2)
                  (6 5 3 3 2)
                  (3 3 5 4 9)
                  (3 5 3 9 0)))

(apply #'seq-mapn #'list testinput)


(defun visible (ind coll)
  (let ((t (nth ind coll))
        (trees-before (seq-take coll ind))
        (trees-after (nthcdr (1+ ind) coll)))
    (or (seq-every-p (lambda (i) (> t i)) trees-before)
        (seq-every-p (lambda (i) (> t i)) trees-after))))

(defun get-visible-trees (treemap)
  (let ((rows treemap)
        (columns (apply #'seq-mapn #'list treemap)))
    (dolist (x (number-sequence (length treemap)))
      (visible x )))
  )


(setq input-day-6 (with-temp-buffer (insert-file-contents "./input/input-day-6.txt")
                                    (buffer-string)))



(thread-first input-day-6
              (partition-by-step 4 1)
              (thread-last
                (seq-take-while (lambda (i) (if (eq (seq-length i)
                                               (seq-length (seq-uniq i)))
                                           nil
                                         t)))

                (last)
                (car))
              (string-match input-day-6)
              (+ 5))
#+end_src

#+RESULTS:
: 1953

*** Part 2

#+begin_src elisp :results pp replace :exports both
(require 'seq)
(require 'cl-lib)

(setq testinput "mjqjpqmgbljsphdztnvjfqwrcgsmlb")

(defun partition-by-step (sequence n step)
  (let ((total '()))
    (while (not (seq-empty-p sequence))
      (setq total (concat total (seq-take sequence n)))
      (setq sequence (seq-drop sequence step))
      )
    (seq-partition total n))
  )


(thread-first testinput
              (partition-by-step 14 1)
              (thread-last
                (seq-take-while (lambda (i) (if (eq (seq-length i)
                                               (seq-length (seq-uniq i)))
                                           nil
                                         t)))
                (last)
                (car)
                )
              (string-match testinput)
              (+ 15))


(setq input-day-6 (with-temp-buffer (insert-file-contents "./input/input-day-6.txt")
                                    (buffer-string)))



(thread-first input-day-6
              (partition-by-step 14 1)
              (thread-last
                (seq-take-while (lambda (i) (if (eq (seq-length i)
                                               (seq-length (seq-uniq i)))
                                           nil
                                         t)))

                (last)
                (car))
              (string-match input-day-6)
              (+ 15))
#+end_src

#+RESULTS:
: 2301

* Day 9

** Clojure
*** Part 1
#+begin_src clojure :results value pp replace :exports both
(def testinput ["R" 4
                "U" 4
                "L" 3
                "D" 1
                "R" 4
                "D" 1
                "L" 5
                "R" 2])


(defn expand-row-r [coll]
  (conj coll "."))

(defn expand-row-l [coll]
  (conj coll "."))

(defn make-game-board [r c]
  (into '[]
        (for [i (range r)]
          (into '[] (repeat c ".")))))


(defn right [[x y]]
  [(inc x) y])

(defn left [[x y]]
  [(dec x) y])

(defn up [[x y]]
  [x (dec y)])

(defn down [[x y]]
  [x (inc y)])

(defn head-tail-distance [[hx hy] [tx ty]]
  [(- hx tx)
   (- hy ty)])

(defn process-instructions [inst]
  (loop [last-head-pos []])
  )
#+end_src

#+RESULTS:
: 1851
:
*** Part 2

#+begin_src clojure :results value pp replace :exports both
(def testinput [[3 0 3 7 3]
                [2 5 5 1 2]
                [6 5 3 3 2]
                [3 3 5 4 9]
                [3 5 3 9 0]] )


(defn my-take-while [i coll]
  (loop [[x & xs] coll acc []]
    (if x
      (cond (= x i) (conj acc true)
            (< i x) (conj acc true)
            (> i x) (recur xs (conj acc true))
            :else acc)
      acc)))

(defn count-visible-trees? [ind coll]
  (let [t (nth coll ind)
        trees-before (reverse (take ind coll))
        trees-after (nthrest coll (inc ind))]
    (* (count (my-take-while t trees-before))
       (count (my-take-while t trees-after)))
    ))

(->> testinput
     (second)
     (visible? 2))


(defn get-visible-trees [treemap]
  (let [rows treemap
        columns (partition (count treemap) (apply interleave treemap))]
    (for [x (range 0 (count treemap)) y (range 0 (count (first treemap)))]
      (* (count-visible-trees? y (nth rows x))
          (count-visible-trees? x (nth columns y)))

      )))

(apply max (get-visible-trees testinput))

(def input-day-8 (->> "./input/input-day-8.txt"
                      (slurp)
                      (clojure.string/split-lines)
                      (map #(clojure.string/split % #""))
                      (mapv (fn [i] (mapv #(Integer/parseInt %) i)))))

(apply max (get-visible-trees input-day-8))
#+end_src

#+RESULTS:
: 574080
:


** Elisp
*** Part 1

#+begin_src elisp :results pp replace :exports both
(require 'seq)
(require 'cl-lib)

(setq testinput '((3 0 3 7 3)
                  (2 5 5 1 2)
                  (6 5 3 3 2)
                  (3 3 5 4 9)
                  (3 5 3 9 0)))

(apply #'seq-mapn #'list testinput)


(defun visible (ind coll)
  (let ((t (nth ind coll))
        (trees-before (seq-take coll ind))
        (trees-after (nthcdr (1+ ind) coll)))
    (or (seq-every-p (lambda (i) (> t i)) trees-before)
        (seq-every-p (lambda (i) (> t i)) trees-after))))

(defun get-visible-trees (treemap)
  (let ((rows treemap)
        (columns (apply #'seq-mapn #'list treemap)))
    (dolist (x (number-sequence (length treemap)))
      (visible x )))
  )


(setq input-day-6 (with-temp-buffer (insert-file-contents "./input/input-day-6.txt")
                                    (buffer-string)))



(thread-first input-day-6
              (partition-by-step 4 1)
              (thread-last
                (seq-take-while (lambda (i) (if (eq (seq-length i)
                                               (seq-length (seq-uniq i)))
                                           nil
                                         t)))

                (last)
                (car))
              (string-match input-day-6)
              (+ 5))
#+end_src

#+RESULTS:
: 1953

*** Part 2

#+begin_src elisp :results pp replace :exports both
(require 'seq)
(require 'cl-lib)

(setq testinput "mjqjpqmgbljsphdztnvjfqwrcgsmlb")

(defun partition-by-step (sequence n step)
  (let ((total '()))
    (while (not (seq-empty-p sequence))
      (setq total (concat total (seq-take sequence n)))
      (setq sequence (seq-drop sequence step))
      )
    (seq-partition total n))
  )


(thread-first testinput
              (partition-by-step 14 1)
              (thread-last
                (seq-take-while (lambda (i) (if (eq (seq-length i)
                                               (seq-length (seq-uniq i)))
                                           nil
                                         t)))
                (last)
                (car)
                )
              (string-match testinput)
              (+ 15))


(setq input-day-6 (with-temp-buffer (insert-file-contents "./input/input-day-6.txt")
                                    (buffer-string)))



(thread-first input-day-6
              (partition-by-step 14 1)
              (thread-last
                (seq-take-while (lambda (i) (if (eq (seq-length i)
                                               (seq-length (seq-uniq i)))
                                           nil
                                         t)))

                (last)
                (car))
              (string-match input-day-6)
              (+ 15))
#+end_src

#+RESULTS:
: 2301
